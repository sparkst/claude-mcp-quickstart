# Troubleshooting Guide - Common Issues and Solutions

> **Complete troubleshooting reference for the CLAUDE.md workflow system with specific solutions and recovery procedures**

## Table of Contents
1. [Requirements and Planning Issues](#requirements-and-planning-issues)
2. [TDD and Testing Problems](#tdd-and-testing-problems)
3. [Code Quality Gate Failures](#code-quality-gate-failures)
4. [Agent Coordination Issues](#agent-coordination-issues)
5. [Workflow Integration Problems](#workflow-integration-problems)
6. [Performance and Scalability Issues](#performance-and-scalability-issues)
7. [Emergency Recovery Procedures](#emergency-recovery-procedures)

---

## Requirements and Planning Issues

### Problem: Vague or Incomplete Requirements

**Symptoms:**
- Tests generated by test-writer are too generic
- Implementation keeps changing direction
- Quality gates fail due to unclear acceptance criteria

**Diagnosis:**
```bash
# Check requirements quality
cat requirements/current.md

# Look for these issues:
‚ùå "Improve user experience" (too vague)
‚ùå Missing acceptance criteria
‚ùå No clear success metrics
‚ùå Undefined edge cases
```

**Solution:**
```markdown
# ‚ùå Vague requirement
## REQ-101: Improve user login

# ‚úÖ Specific requirement
## REQ-101: Add password strength indicator to login form
- Acceptance:
  - Real-time strength feedback (weak/medium/strong)
  - Visual indicator updates as user types
  - Minimum 8 characters with mixed case required
  - Displays specific missing requirements (e.g., "Needs uppercase letter")
  - Indicator appears immediately when password field is focused
- Non-Goals: Password generation suggestions, breach checking
- Dependencies: Existing login form component
- Test Scenarios:
  - Empty password shows no indicator
  - "weak123" shows weak (missing uppercase, special chars)
  - "Secure123!" shows strong
  - Real-time updates during typing
```

### Problem: Requirements Drift During Implementation

**Symptoms:**
- Original REQ-IDs no longer match implemented features
- Tests pass but don't validate actual business needs
- Requirements.lock.md out of sync with implementation

**Diagnosis:**
```bash
# Compare requirements vs implementation
diff requirements/current.md requirements/requirements.lock.md

# Check test coverage alignment
grep -r "REQ-" src/**/*.spec.ts
grep -r "REQ-" requirements/requirements.lock.md
```

**Solution:**
```bash
# 1. Lock requirements at start of development
QNEW "Feature implementation"
# This creates requirements.lock.md snapshot

# 2. Reference locked requirements in tests
test('REQ-101 ‚Äî password strength shows real-time feedback', () => {
  // Test must validate requirements.lock.md acceptance criteria
});

# 3. Block scope creep with new REQ-IDs
# New requirements = new REQ-IDs = new development cycle

# 4. Use QCHECK to validate against original requirements
QCHECK
# PE-Reviewer validates implementation matches locked requirements
```

### Problem: Conflicting Requirements

**Symptoms:**
- Multiple REQ-IDs contradict each other
- Implementation can't satisfy all requirements simultaneously
- Tests fail when trying to validate conflicting criteria

**Example Conflict:**
```markdown
## REQ-201: Users must be able to change passwords immediately
- Acceptance: Password change form accessible without verification

## REQ-202: Password changes require current password verification
- Acceptance: User must enter current password before setting new one
```

**Resolution Process:**
```markdown
# 1. Document the conflict
## CONFLICT-01: REQ-201 vs REQ-202 - Password Change Verification

## 2. Analyze business requirements
- Security requirement (REQ-202) typically takes precedence
- User experience (REQ-201) can be satisfied within security constraints

## 3. Resolve with new requirement
## REQ-203: Secure password change with UX optimization
- Acceptance:
  - Current password verification required (satisfies REQ-202)
  - Password strength indicator during entry (improves UX from REQ-201)
  - Clear error messages for failed verification
  - Auto-focus on current password field for quick access

## 4. Archive conflicting requirements
- Move REQ-201 and REQ-202 to requirements/archive/conflicts/
- Update references to point to REQ-203
```

---

## TDD and Testing Problems

### Problem: test-writer Generates Tests That Immediately Pass

**Symptoms:**
```bash
QCODE
# test-writer generates tests
npm test
‚úÖ All tests pass immediately
‚ùå TDD violation: tests should fail first
```

**Diagnosis:**
```bash
# Check if implementation already exists
find src -name "*password*" -type f
ls src/**/*login*

# Check test specificity
cat src/**/*.spec.ts | grep "expect"
# Look for vague assertions like toBeTruthy(), toBeGreaterThan(0)
```

**Solution:**

1. **Delete existing implementation:**
```bash
# Remove implementation to force failing tests
rm src/auth/password-reset.ts
npm test
# Should now show failures
```

2. **Make tests more specific:**
```typescript
// ‚ùå Test that passes without implementation
test('REQ-101 ‚Äî returns a result', () => {
  const result = calculateDiscount(100, 10);
  expect(result).toBeTruthy(); // Too vague
});

// ‚úÖ Test that fails without implementation
test('REQ-101 ‚Äî calculates 10% discount correctly', () => {
  const originalPrice = 100;
  const discountPercent = 10;
  const expectedDiscountedPrice = 90;

  const result = calculateDiscount(originalPrice, discountPercent);
  expect(result).toBe(expectedDiscountedPrice); // Specific assertion
});
```

3. **Use test-writer validation:**
```bash
# Re-run QCODE with stricter validation
QCODE
# test-writer now validates tests fail before allowing implementation
```

### Problem: Flaky or Unreliable Tests

**Common Causes and Solutions:**

#### Time-Based Flakiness
```typescript
// ‚ùå Flaky: depends on exact timing
test('token expires after 15 minutes', (done) => {
  const token = generateToken();
  setTimeout(() => {
    expect(isValidToken(token)).toBe(false);
    done();
  }, 15 * 60 * 1000); // 15 minutes - too long and unreliable
});

// ‚úÖ Stable: test the logic, not real time
test('REQ-401 ‚Äî token expires after 15 minutes', () => {
  const mockNow = new Date('2024-01-01T12:00:00Z');
  vi.useFakeTimers();
  vi.setSystemTime(mockNow);

  const token = generateToken();
  expect(token.expiresAt).toEqual(new Date('2024-01-01T12:15:00Z'));

  vi.useRealTimers();
});
```

#### External Dependency Flakiness
```typescript
// ‚ùå Flaky: depends on external email service
test('sends reset email', async () => {
  await service.requestReset('user@example.com');
  // This could fail if email service is down
});

// ‚úÖ Stable: mock external dependencies
test('REQ-401 ‚Äî sends reset email to verified user', async () => {
  const mockEmailService = {
    sendResetEmail: vi.fn().mockResolvedValue(true)
  };
  const service = new PasswordResetService(mockEmailService);

  await service.requestReset('user@example.com');
  expect(mockEmailService.sendResetEmail).toHaveBeenCalledWith(
    'user@example.com',
    expect.stringMatching(/^[a-f0-9]{64}$/)
  );
});
```

#### Database State Flakiness
```typescript
// ‚ùå Flaky: depends on database state
test('creates unique user', async () => {
  const user = await createUser({ email: 'test@example.com' });
  expect(user.id).toBeDefined();
  // Fails if user already exists from previous test
});

// ‚úÖ Stable: clean database state
describe('User Creation', () => {
  beforeEach(async () => {
    await db.raw('TRUNCATE TABLE users CASCADE');
  });

  test('REQ-301 ‚Äî creates user with unique email', async () => {
    const userData = { email: 'test@example.com', name: 'Test User' };
    const user = await createUser(userData);

    expect(user.id).toBeDefined();
    expect(user.email).toBe(userData.email);
  });
});
```

### Problem: Property-Based Tests Are Too Slow

**Symptoms:**
```bash
npm test
# Tests take 30+ seconds
# Property-based tests running too many iterations
```

**Solution:**
```typescript
// Configure fast-check for reasonable performance
fc.configureGlobal({
  numRuns: 50,         // Reduce from default 100
  maxSkipsPerRun: 100,
  timeout: 5000        // 5 second timeout per test
});

// Or configure per-test for expensive operations
test('REQ-501 ‚Äî encryption properties', () => {
  fc.assert(
    fc.property(
      fc.string({ minLength: 1, maxLength: 100 }),
      (plaintext) => {
        const encrypted = encrypt(plaintext, key);
        const decrypted = decrypt(encrypted, key);
        expect(decrypted).toBe(plaintext);
      }
    ),
    { numRuns: 20 } // Fewer runs for expensive crypto operations
  );
});

// Separate slow tests into different suites
describe('crypto properties (slow)', () => {
  // Run these tests less frequently or in CI only
});
```

---

## Code Quality Gate Failures

### Problem: High Cyclomatic Complexity

**PE-Reviewer Error:**
```
‚ùå Function has high cyclomatic complexity: 15 (threshold: 10)
Function: processUserOrder
```

**Diagnosis:**
```typescript
// Check the flagged function
function processUserOrder(user, order, options) {
  if (user.type === 'premium') {
    if (order.total > 100) {
      if (options.expedited) {
        // ... many nested conditions
      } else {
        // ...
      }
    } else {
      // ...
    }
  } else if (user.type === 'standard') {
    // ... more branches
  }
  // Complexity = number of decision points
}
```

**Solution: Extract Functions**
```typescript
// ‚úÖ Refactored with lower complexity
function processUserOrder(user, order, options) {
  if (!isEligibleForProcessing(user, order)) {
    return createErrorResponse('INELIGIBLE_ORDER');
  }

  const pricing = calculatePricing(user, order, options);
  const shipping = calculateShipping(user, order, options);

  return createOrderResponse(pricing, shipping);
}

function isEligibleForProcessing(user, order) {
  return user.verified && order.total > 0 && order.items.length > 0;
}

function calculatePricing(user, order, options) {
  if (user.type === 'premium') {
    return calculatePremiumPricing(order, options);
  }
  return calculateStandardPricing(order, options);
}

function calculatePremiumPricing(order, options) {
  const basePrice = order.total;
  const discount = options.expedited ? 0 : 0.1;
  return basePrice * (1 - discount);
}
```

### Problem: security-reviewer Identifies Vulnerabilities

#### SQL Injection Risk
**Error:**
```
üõ°Ô∏è CRITICAL: SQL Injection vulnerability detected
Line 42: const query = `SELECT * FROM users WHERE email = '${email}'`
```

**Solution:**
```typescript
// ‚ùå Vulnerable to SQL injection
const query = `SELECT * FROM users WHERE email = '${email}'`;
const result = await db.execute(query);

// ‚úÖ Use parameterized queries
const query = 'SELECT * FROM users WHERE email = ?';
const result = await db.execute(query, [email]);

// Or with named parameters
const query = 'SELECT * FROM users WHERE email = :email';
const result = await db.execute(query, { email });
```

#### XSS Vulnerability
**Error:**
```
üõ°Ô∏è HIGH: XSS vulnerability in template rendering
Line 18: innerHTML = `<div>Welcome ${user.name}</div>`
```

**Solution:**
```typescript
// ‚ùå Vulnerable to XSS
element.innerHTML = `<div>Welcome ${user.name}</div>`;

// ‚úÖ Escape user input
import { escapeHtml } from './utils/security';
element.innerHTML = `<div>Welcome ${escapeHtml(user.name)}</div>`;

// Or use safe DOM manipulation
const welcomeDiv = document.createElement('div');
welcomeDiv.textContent = `Welcome ${user.name}`;
element.appendChild(welcomeDiv);
```

#### Weak Cryptography
**Error:**
```
üõ°Ô∏è HIGH: Cryptographically weak random number generation
Line 25: const token = Math.random().toString(36)
```

**Solution:**
```typescript
// ‚ùå Predictable tokens
const token = Math.random().toString(36);

// ‚úÖ Cryptographically secure tokens
import crypto from 'crypto';
const token = crypto.randomBytes(32).toString('hex');

// For additional entropy (defense in depth)
function generateSecureToken() {
  const randomBytes = crypto.randomBytes(32);
  const timestamp = Date.now().toString();
  const combined = Buffer.concat([randomBytes, Buffer.from(timestamp)]);
  return crypto.createHash('sha256').update(combined).digest('hex');
}
```

### Problem: Test Quality Issues

**test-writer Error:**
```
‚ùå Test quality issues detected:
- Uses magic numbers without explanation
- Test description doesn't match assertion
- Weak assertion (toBeGreaterThan instead of toBe)
```

**Solution:**
```typescript
// ‚ùå Poor test quality
test('validates age', () => {
  expect(validateAge(25)).toBeGreaterThan(0); // Weak assertion
});

// ‚úÖ High quality test
test('REQ-201 ‚Äî validates adult age as exactly true for 25 years old', () => {
  const adultAge = 25;
  const isValid = validateAge(adultAge);

  expect(isValid).toBe(true); // Strong, specific assertion
});
```

---

## Agent Coordination Issues

### Problem: Multiple Agents Provide Conflicting Advice

**Scenario:**
```
PE-Reviewer: "Extract this function to reduce complexity"
security-reviewer: "Keep this logic inline to prevent information leakage"
```

**Resolution Process:**

1. **Check Priority Order:**
   ```typescript
   const agentPriority = [
     'security-reviewer',  // Highest - security always wins
     'PE-Reviewer',        // Quality second
     'test-writer',        // Testing third
     'debugger',          // Support role
     'docs-writer',       // Documentation
     'planner'            // Planning support
   ];
   ```

2. **Apply Conflict Resolution:**
   ```markdown
   ## CONFLICT RESOLUTION: REQ-401 Function Extraction

   **Conflict**: PE-Reviewer vs security-reviewer on password validation function

   **Resolution**: security-reviewer priority (security > quality)
   **Decision**: Keep password validation logic inline
   **Rationale**: Prevents potential information leakage through function boundaries
   **Compensation**: Add detailed comments for readability

   **Implementation**:
   ```typescript
   function validatePassword(password) {
     // Inline validation to prevent information leakage via function calls
     // security-reviewer: Keep validation logic contained for security audit
     const hasMinLength = password.length >= 8;
     const hasUppercase = /[A-Z]/.test(password);
     const hasLowercase = /[a-z]/.test(password);
     const hasNumber = /\d/.test(password);
     const hasSpecial = /[!@#$%^&*]/.test(password);

     return hasMinLength && hasUppercase && hasLowercase && hasNumber && hasSpecial;
   }
   ```

### Problem: Agent Doesn't Activate When Expected

**Symptoms:**
```bash
QCHECK
# Expected security-reviewer to activate for crypto code
# Only PE-Reviewer ran
```

**Diagnosis:**
```bash
# 1. Check if patterns are detected
grep -r "crypto\|password\|hash" src/
# If patterns exist, check agent configuration

# 2. Verify agent activation patterns
cat .claude/agents/security-reviewer.md

# 3. Check activation thresholds
cat .claude/config/agent-config.ts
```

**Solution:**

1. **Manual Activation:**
   ```bash
   # Force agent activation
   "security-reviewer please analyze the password hashing implementation in src/auth/password.ts"
   ```

2. **Fix Activation Patterns:**
   ```typescript
   // Update security patterns to catch your specific case
   const securityPatterns = {
     crypto: [
       /crypto\./,
       /bcrypt/,
       /scrypt/,
       /hash.*password/i,  // Add missing pattern
       /password.*hash/i   // Add missing pattern
     ]
   };
   ```

3. **Lower Activation Thresholds:**
   ```json
   {
     "agents": {
       "security-reviewer": {
         "activationThresholds": {
           "cryptoPatterns": 1,  // Activate on any crypto pattern
           "authPatterns": 1     // Lower threshold
         }
       }
     }
   }
   ```

### Problem: Agent Handoff Failures

**Symptoms:**
```
PE-Reviewer completed analysis
‚ùå Failed to hand off to security-reviewer
Workflow stuck at QCHECK phase
```

**Diagnosis:**
```bash
# Check agent communication logs
cat .claude/logs/agent-handoffs.log

# Look for handoff errors
grep "HANDOFF_FAILED" .claude/logs/*.log
```

**Solution:**

1. **Retry Handoff:**
   ```bash
   # Manual agent coordination
   "PE-Reviewer please hand off security analysis to security-reviewer for crypto operations review"
   ```

2. **Reset Agent State:**
   ```bash
   # Clear agent state and restart
   rm .claude/cache/agent-state.json
   QCHECK # Restart quality review
   ```

3. **Sequential Agent Activation:**
   ```bash
   # Run agents separately if coordination fails
   QCHECKF  # PE-Reviewer only
   "security-reviewer please review crypto implementation"
   ```

---

## Workflow Integration Problems

### Problem: QGIT Fails Due to Quality Gate Violations

**Symptoms:**
```bash
QGIT
‚ùå Quality gates failed:
  - Tests failing: 3 tests
  - Linting errors: 5 issues
  - Type errors: 2 files
  - Security issues: 1 high priority
```

**Recovery Process:**

1. **Diagnose Individual Gates:**
   ```bash
   # Check each gate separately
   npm test                    # Test failures
   npm run lint               # Linting issues
   npm run typecheck          # Type errors
   npm run security:scan      # Security scan
   ```

2. **Fix Tests:**
   ```bash
   npm test -- --reporter=verbose
   # Fix failing tests one by one
   # Use debugger agent for assistance
   "debugger please analyze test failure in password-reset.spec.ts"
   ```

3. **Fix Linting:**
   ```bash
   npm run lint -- --fix      # Auto-fix simple issues
   npm run format             # Auto-format code
   # Manual fixes for remaining issues
   ```

4. **Fix Type Errors:**
   ```bash
   npx tsc --noEmit          # See all type errors
   # Fix type errors with PE-Reviewer guidance
   QCHECKF src/auth/types.ts
   ```

5. **Address Security Issues:**
   ```bash
   # Get specific security guidance
   "security-reviewer please provide specific remediation for identified issues"
   ```

6. **Re-run QGIT:**
   ```bash
   QGIT
   ‚úÖ All quality gates passed
   ```

### Problem: Workflow Interruption and Recovery

**Scenario:**
```
QCODE ‚Üí Implementation 50% complete ‚Üí System crash/interruption
Need to resume workflow safely
```

**Recovery Process:**

1. **Assess Current State:**
   ```bash
   # Check what was completed
   git status
   git diff

   # Check test state
   npm test

   # Check requirements lock
   cat requirements/requirements.lock.md
   ```

2. **Resume from Safe Point:**
   ```bash
   # If tests were written but implementation incomplete
   npm test  # Should show failing tests
   QCODE     # Resume implementation

   # If implementation was complete but not reviewed
   QCHECK    # Run quality review

   # If everything was done but not committed
   QGIT      # Complete commit process
   ```

3. **Handle Partial Implementation:**
   ```bash
   # If implementation is partially complete
   git stash                    # Save partial work
   QCODE                       # Start fresh with TDD
   git stash pop               # Reapply partial work
   # Fix any conflicts and continue
   ```

---

## Performance and Scalability Issues

### Problem: Slow Test Suite Execution

**Symptoms:**
```bash
npm test
# Takes 5+ minutes for 100 tests
# Blocks development workflow
```

**Solutions:**

1. **Parallel Test Execution:**
   ```typescript
   // vitest.config.ts
   export default defineConfig({
     test: {
       pool: 'threads',
       poolOptions: {
         threads: {
           maxThreads: 4,
           minThreads: 2
         }
       }
     }
   });
   ```

2. **Test Categorization:**
   ```typescript
   // Separate fast and slow tests
   describe('unit tests (fast)', () => {
     test('validates email format', () => {
       // Fast validation logic
     });
   });

   describe('integration tests (slow)', { timeout: 10000 }, () => {
     test('creates user end-to-end', async () => {
       // Slower database operations
     });
   });
   ```

3. **Mock Heavy Dependencies:**
   ```typescript
   // Mock database for unit tests
   vi.mock('./database', () => ({
     findUser: vi.fn().mockResolvedValue({ id: 1, email: 'test@example.com' }),
     createUser: vi.fn().mockResolvedValue({ id: 2, email: 'new@example.com' })
   }));
   ```

4. **Optimize Property-Based Tests:**
   ```typescript
   // Reduce test runs for expensive operations
   test('crypto operations properties', () => {
     fc.assert(
       fc.property(fc.string(), (input) => {
         // Expensive crypto operation
       }),
       { numRuns: 20 } // Reduced from default 100
     );
   });
   ```

### Problem: Agent Analysis Takes Too Long

**Symptoms:**
```bash
QCHECK
# Takes 2+ minutes to analyze 50 lines of code
# Blocks development flow
```

**Solutions:**

1. **Incremental Analysis:**
   ```bash
   # Analyze only changed files
   git diff --name-only HEAD~1 | xargs -I {} QCHECKF {}

   # Instead of full codebase analysis
   QCHECK  # Analyzes entire project
   ```

2. **Selective Agent Activation:**
   ```bash
   # For minor changes, skip comprehensive review
   git diff --stat
   # Only CSS changes? Skip security review
   QCHECKF  # Function quality only
   ```

3. **Cache Agent Results:**
   ```json
   // .claude/cache/analysis-cache.json
   {
     "src/utils/helpers.ts": {
       "lastModified": "2024-01-15T10:30:00Z",
       "hash": "abc123",
       "qualityScore": 95,
       "issues": []
     }
   }
   ```

4. **Parallel Agent Execution:**
   ```typescript
   // Run multiple agents simultaneously
   const analysisResults = await Promise.all([
     peReviewer.analyze(code),
     securityReviewer.analyze(code),
     testWriter.validateTests(tests)
   ]);
   ```

---

## Emergency Recovery Procedures

### Emergency: Production Security Vulnerability

**Scenario:**
```
üö® CRITICAL: Password reset tokens stored in plain text in production
üö® Immediate account takeover risk
```

**Immediate Response (< 1 hour):**

1. **Assess Scope:**
   ```bash
   # Check production logs for exposed tokens
   grep "reset_token" /var/log/app/*.log

   # Check database for plain text tokens
   psql -c "SELECT COUNT(*) FROM reset_tokens WHERE token_hash NOT LIKE '$%';"
   ```

2. **Immediate Mitigation:**
   ```sql
   -- Invalidate all existing reset tokens
   UPDATE reset_tokens SET used = true, invalidated_at = NOW()
   WHERE used = false;

   -- Clear any logs containing tokens
   -- (Coordinate with DevOps team)
   ```

3. **Emergency Hotfix:**
   ```bash
   git checkout -b hotfix/security-token-hashing

   # Skip normal workflow for emergency
   "security-reviewer urgently analyze token storage vulnerability"

   # Implement fix
   cat > src/auth/secure-token.ts << 'EOF'
   import crypto from 'crypto';

   export function hashToken(token: string): string {
     return crypto.createHash('sha256').update(token).digest('hex');
   }
   EOF

   # Deploy immediately
   git add .
   git commit -m "SECURITY: Hash password reset tokens

   CRITICAL: Fix plain text token storage vulnerability
   - Hash tokens before database storage
   - Update existing tokens with hash
   - Invalidate all current tokens for safety"

   git push origin hotfix/security-token-hashing
   # Deploy to production immediately
   ```

4. **Post-Incident Actions:**
   ```bash
   # After hotfix deployment
   QDOC "Document security incident and prevention measures"

   # Update security patterns to catch this issue
   # Add to .claude/agents/security-reviewer.md:
   # - Pattern: /token.*=.*[^hash|^encrypt]/
   # - Alert: Tokens should be hashed before storage
   ```

### Emergency: Complete Workflow System Failure

**Scenario:**
```
‚ùå All agents failing to activate
‚ùå QCODE, QCHECK, QGIT all broken
‚ùå Need to continue development without workflow
```

**Recovery Steps:**

1. **Switch to Manual Mode:**
   ```bash
   # Disable agent system temporarily
   mv .claude .claude.backup

   # Continue with manual development
   npm test
   npm run lint
   npm run typecheck
   git add .
   git commit -m "Manual commit while workflow system recovery in progress"
   ```

2. **Diagnose Agent System:**
   ```bash
   # Check agent configuration
   cat .claude.backup/settings.json

   # Check for corrupted files
   find .claude.backup -name "*.json" -exec json_verify {} \;

   # Check permissions
   ls -la .claude.backup/
   ```

3. **Restore from Known Good State:**
   ```bash
   # Restore from git if available
   git checkout HEAD~5 -- .claude/

   # Or recreate basic configuration
   mkdir -p .claude/agents
   cat > .claude/settings.json << 'EOF'
   {
     "defaultMode": "acceptEdits",
     "permissions": {
       "allow": ["Read(./**)", "Edit(./**)", "Bash(npm run test)"]
     }
   }
   EOF
   ```

4. **Gradual Re-activation:**
   ```bash
   # Test basic workflow
   echo "QNEW test" # Should work now

   # Add agents one by one
   cp .claude.backup/agents/test-writer.md .claude/agents/
   QCODE # Test test-writer

   # Continue until all agents restored
   ```

### Emergency: Corrupted Requirements State

**Scenario:**
```
‚ùå requirements.lock.md corrupted or missing
‚ùå Tests reference REQ-IDs that don't exist
‚ùå Implementation doesn't match requirements
```

**Recovery Process:**

1. **Backup Current State:**
   ```bash
   cp requirements/current.md requirements/recovery-backup.md
   git stash push -m "Backup current implementation"
   ```

2. **Reconstruct Requirements from Tests:**
   ```bash
   # Extract REQ-IDs from tests
   grep -r "REQ-[0-9]*" src/**/*.spec.ts > requirements/extracted-req-ids.txt

   # Analyze what each test validates
   for req_id in $(grep -o "REQ-[0-9]*" requirements/extracted-req-ids.txt | sort -u); do
     echo "## $req_id: [Reconstructed from tests]"
     grep -A 5 -B 5 "$req_id" src/**/*.spec.ts
     echo ""
   done > requirements/reconstructed.md
   ```

3. **Validate Against Implementation:**
   ```bash
   # Check what's actually implemented
   git diff --name-only HEAD~10  # Last 10 commits

   # Map implementation to requirements
   "planner please analyze current implementation and generate matching requirements"
   ```

4. **Create New Requirements Lock:**
   ```bash
   # Merge reconstructed with current
   cat requirements/reconstructed.md requirements/current.md > requirements/merged.md

   # Remove duplicates and conflicts
   # Manual review and cleanup

   cp requirements/merged.md requirements/requirements.lock.md
   ```

This comprehensive troubleshooting guide provides solutions for the most common issues encountered in the CLAUDE.md workflow system, from simple configuration problems to emergency security incidents.